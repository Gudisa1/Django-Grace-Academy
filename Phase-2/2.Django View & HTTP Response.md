# 6. Your First Django View & HTTP Response

## üìå **Understanding Django Views**

A **view** in Django is a Python function that:
1. Receives a web **request**
2. Processes data (optional)
3. Returns a web **response** (HTML, JSON, text, etc.)

It's the **controller** in MVC pattern.

---

## üèóÔ∏è **Step 1: Create a Basic View**

### **Location:** `blog/views.py`

```python
from django.http import HttpResponse

# Simplest possible view
def hello_world(request):
    return HttpResponse("Hello, World! üåç")

# View with HTML
def welcome_page(request):
    return HttpResponse("<h1>Welcome to My Blog</h1><p>This is our home page.</p>")

# View with dynamic content
def greet_user(request, name):
    return HttpResponse(f"Hello, {name}! üëã")
```

---

## üéØ **Step 2: Understanding `HttpResponse`**

### **What is `HttpResponse`?**
- The basic way to return content to the browser
- Can return HTML, text, JSON, or any content type
- Takes content as a string

### **Import Statement:**
```python
from django.http import HttpResponse
```

### **Customizing the Response:**
```python
def custom_response(request):
    # Create response with custom status and headers
    response = HttpResponse(
        "<h2>Custom Response</h2>",
        content_type="text/html",
        status=201  # HTTP status code
    )
    response['X-Custom-Header'] = 'MyValue'
    return response
```

### **Different Response Types:**
```python
# Plain text
def text_view(request):
    return HttpResponse("Plain text", content_type="text/plain")

# JSON response
import json
def json_view(request):
    data = {"message": "Success", "status": 200}
    return HttpResponse(
        json.dumps(data),
        content_type="application/json"
    )

# XML response
def xml_view(request):
    xml_content = '''<?xml version="1.0"?>
    <note>
        <to>User</to>
        <from>Django</from>
        <heading>Welcome</heading>
    </note>'''
    return HttpResponse(xml_content, content_type="application/xml")
```

---

## üîó **Step 3: Connect View to URL**

### **1. Update `blog/urls.py`:**
```python
from django.urls import path
from . import views

urlpatterns = [
    path('hello/', views.hello_world, name='hello'),
    path('welcome/', views.welcome_page, name='welcome'),
    path('greet/<str:name>/', views.greet_user, name='greet'),
    path('custom/', views.custom_response, name='custom'),
]
```

### **2. URL Pattern Explanation:**
- `'hello/'` ‚Üí `http://127.0.0.1:8000/blog/hello/`
- `'greet/<str:name>/'` ‚Üí `http://127.0.0.1:8000/blog/greet/John/`

### **3. Path Converters:**
```python
# In urls.py
path('user/<int:user_id>/', views.user_detail),  # Integer
path('post/<slug:post_slug>/', views.post_detail),  # Slug (letters, hyphens, underscores)
path('article/<uuid:article_id>/', views.article_detail),  # UUID
path('path/<path:subpath>/', views.path_view),  # URL path including slashes
```

---

## üåê **Step 4: Test in Browser**

### **Run your server:**
```bash
python manage.py runserver
```

### **Test each URL:**
1. **http://127.0.0.1:8000/blog/hello/**
   - Shows: "Hello, World! üåç"

2. **http://127.0.0.1:8000/blog/welcome/**
   - Shows HTML: "<h1>Welcome to My Blog</h1>"

3. **http://127.0.0.1:8000/blog/greet/Alice/**
   - Shows: "Hello, Alice! üëã"

4. **http://127.0.0.1:8000/blog/greet/Bob/**
   - Shows: "Hello, Bob! üëã"

---

## üìä **Step 5: View with Data Processing**

### **Add more complex logic:**
```python
from django.http import HttpResponse
import datetime

# View with date/time
def current_time(request):
    now = datetime.datetime.now()
    html = f"""
    <html>
        <body>
            <h1>Current Server Time</h1>
            <p>Date: {now.date()}</p>
            <p>Time: {now.time()}</p>
            <p>Full: {now}</p>
        </body>
    </html>
    """
    return HttpResponse(html)

# View with request inspection
def inspect_request(request):
    info = f"""
    <h2>Request Information</h2>
    <ul>
        <li>Method: {request.method}</li>
        <li>Path: {request.path}</li>
        <li>GET params: {request.GET}</li>
        <li>User Agent: {request.META.get('HTTP_USER_AGENT', 'Unknown')}</li>
        <li>Remote IP: {request.META.get('REMOTE_ADDR', 'Unknown')}</li>
    </ul>
    """
    return HttpResponse(info)

# View with query parameters
def search_view(request):
    # Access URL parameters: /blog/search/?q=django&page=1
    query = request.GET.get('q', '')  # Default empty string
    page = request.GET.get('page', '1')
    
    response = f"""
    <h2>Search Results</h2>
    <p>Query: <strong>{query}</strong></p>
    <p>Page: {page}</p>
    """
    
    if query:
        response += f"<p>Searching for: {query}</p>"
    else:
        response += "<p>Please enter a search term</p>"
    
    return HttpResponse(response)
```

### **Add URLs:**
```python
# In blog/urls.py
urlpatterns = [
    # ... previous patterns
    path('time/', views.current_time, name='current_time'),
    path('inspect/', views.inspect_request, name='inspect'),
    path('search/', views.search_view, name='search'),
]
```

### **Test with parameters:**
- **http://127.0.0.1:8000/blog/search/?q=django**
- **http://127.0.0.1:8000/blog/search/?q=python&page=2**

---

## üé® **Step 6: Return Different HTTP Status Codes**

```python
from django.http import HttpResponse

def success_view(request):
    return HttpResponse("Operation successful!", status=200)

def created_view(request):
    return HttpResponse("Resource created", status=201)

def bad_request_view(request):
    return HttpResponse("Invalid request", status=400)

def not_found_view(request):
    return HttpResponse("Page not found", status=404)

def server_error_view(request):
    return HttpResponse("Internal server error", status=500)

def redirect_simulation(request):
    # For actual redirects, use HttpResponseRedirect or redirect()
    return HttpResponse("Redirecting...", status=302, headers={'Location': '/blog/hello/'})
```

---

## üìù **Step 7: View with File Download**

```python
def download_text_file(request):
    # Create a text file response
    response = HttpResponse(
        "This is the content of the file.\nLine 2.\nLine 3.",
        content_type='text/plain'
    )
    response['Content-Disposition'] = 'attachment; filename="example.txt"'
    return response

def download_csv(request):
    import csv
    from io import StringIO
    
    # Create CSV in memory
    csv_buffer = StringIO()
    writer = csv.writer(csv_buffer)
    writer.writerow(['Name', 'Email', 'Age'])
    writer.writerow(['John Doe', 'john@example.com', 25])
    writer.writerow(['Jane Smith', 'jane@example.com', 30])
    
    response = HttpResponse(csv_buffer.getvalue(), content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="users.csv"'
    return response
```

---

## üîç **Step 8: Debugging Views**

### **1. Print to Console:**
```python
def debug_view(request):
    print(f"Request method: {request.method}")
    print(f"Request path: {request.path}")
    print(f"GET params: {dict(request.GET)}")
    
    # Continue with normal response
    return HttpResponse("Check your console for debug info!")
```

### **2. Use Django Debug Toolbar (Optional):**
```bash
pip install django-debug-toolbar
```
Add to `INSTALLED_APPS` and configure per documentation.

---

## üìã **Step 9: View Best Practices**

### **Do:**
```python
# ‚úÖ GOOD: Separate logic, use descriptive names
def get_user_profile(request, user_id):
    """Return user profile information."""
    # Business logic here
    return HttpResponse(f"Profile for user {user_id}")
```

### **Don't:**
```python
# ‚ùå BAD: Too much logic in view
def messy_view(request):
    # Database queries
    # Business logic
    # HTML generation
    # File operations
    # Email sending
    return HttpResponse("Done")
```

### **Better Structure:**
```python
# views.py
def user_dashboard(request):
    user_data = get_user_data(request.user.id)
    stats = calculate_user_stats(user_data)
    context = prepare_dashboard_context(user_data, stats)
    return render_dashboard(request, context)

# services.py (separate file)
def get_user_data(user_id):
    # Database logic
    pass

def calculate_user_stats(data):
    # Business logic
    pass

def prepare_dashboard_context(data, stats):
    # Context preparation
    pass
```

---

## üß™ **Step 10: Testing Your Views**

### **Create a test in `blog/tests.py`:**
```python
from django.test import TestCase
from django.urls import reverse

class ViewTests(TestCase):
    def test_hello_world(self):
        response = self.client.get(reverse('hello'))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "Hello, World")
    
    def test_greet_user(self):
        response = self.client.get('/blog/greet/Alice/')
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "Alice")
    
    def test_search_with_param(self):
        response = self.client.get('/blog/search/?q=django')
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "django")
```

### **Run tests:**
```bash
python manage.py test blog
```

---

## üöÄ **Quick Exercise: Build a Simple Calculator View**

### **Challenge:** Create a view that:
1. Accepts two numbers as URL parameters
2. Performs addition, subtraction, multiplication, division
3. Returns the results in a formatted HTML table

### **Starter code:**
```python
# In views.py
def calculator(request):
    # Your code here
    pass
```

### **Expected URLs:**
- `/blog/calculator/?a=10&b=5`
- Shows a table with: 10 + 5 = 15, 10 - 5 = 5, etc.

---

## üìä **Common Errors & Solutions**

| Error | Solution |
|-------|----------|
| **404 Not Found** | Check `urls.py` patterns and view names |
| **500 Server Error** | Check view code for exceptions |
| **ImportError** | Ensure view is imported correctly in `urls.py` |
| **TypeError** | View must take `request` parameter |
| **No HttpResponse returned** | All paths must return HttpResponse |

---

## üéØ **Key Takeaways**

1. **Views are Python functions** that take `request` and return `HttpResponse`
2. **`HttpResponse`** is the basic building block for all responses
3. **URL patterns** map URLs to views
4. **Request data** accessible via `request.GET`, `request.POST`, `request.method`
5. **Always return** an HttpResponse object

---

## üîú **Next Step Preview: Templates & Dynamic Content**

You've learned to return simple responses. Next, we'll:
- Use HTML templates (`.html` files)
- Pass dynamic data with `context`
- Use template tags and filters
- Extend base templates

**Try this now:** Modify `welcome_page` view to read HTML from a file instead of hardcoding!

---

