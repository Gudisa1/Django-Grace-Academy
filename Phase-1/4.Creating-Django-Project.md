# **In-Depth Lesson: Creating a Django Project & Running the Server**

## **1. Starting a Django Project**

**Command:**

```bash
django-admin startproject myproject
```

### **What happens when you run this?**

1. Django generates a **project skeleton**, which is a set of folders and files that provide the basic “backbone” of a web application.
2. You get a **dual-layer folder structure**:

   * The outer folder (`myproject/`) — holds your project and can contain apps later.
   * The inner folder (`myproject/`) — the actual Python package for your project settings and configurations.

### **Why dual-layer structure?**

* It separates the **project container** (the outer folder) from the **Python package** that Django manages (inner folder).
* This makes it easier to **rename the project** or include additional apps without breaking internal references.

**Analogy:**
Think of it like building a house:

* The outer folder is the **plot of land** — you can add multiple buildings (apps) on it.
* The inner folder is the **main building structure** — where the electricity, plumbing, and wiring (settings and configuration) are defined.

---

## **2. Understanding the Project Structure**

After running the command, you get:

```
myproject/
├── manage.py
└── myproject/
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
```

Let’s unpack each component:

### **a) `manage.py`**

* A **command-line utility**.
* Interacts with your project in a controlled environment.
* Lets you:

  * Run the development server (`runserver`)
  * Apply database migrations (`migrate`)
  * Create apps (`startapp`)
* **Key insight:** It automatically sets the `DJANGO_SETTINGS_MODULE` environment variable, so Django knows which settings to use.

**Analogy:**
Think of `manage.py` as a **remote control for your Django project** — you don’t open the server manually, you press buttons (commands).

---

### **b) Inner `myproject/` folder**

#### **i) `__init__.py`**

* Marks the folder as a Python package.
* Enables you to import code from this folder elsewhere in your project.

#### **ii) `settings.py`**

* The **central configuration file** for your Django project.
* Contains:

  * Installed apps (which Django apps are active)
  * Middleware (functions that process requests/responses)
  * Database connections (SQLite by default)
  * Templates and static file paths
  * Security settings (secret keys, debug mode)

**Key insight:**
Everything in your Django project revolves around `settings.py`. Modifying it changes **how your project behaves globally**.

#### **iii) `urls.py`**

* Maps **URL paths** to **Python functions or views**.
* Example:

  * `/home/` → `home_view` function
  * `/blog/` → `blog_list` function
* Central part of Django’s **MTV (Model-Template-View) pattern**.

#### **iv) `wsgi.py`**

* Entry point for **deployment on a web server** (WSGI = Web Server Gateway Interface).
* Handles **communication between Django and production servers** (like Apache or Nginx + Gunicorn).
* For development, you don’t touch this often, but it’s crucial for production.

---

### **3. Running the Development Server**

**Command:**

```bash
python manage.py runserver
```

#### **What this does internally**

1. **Starts a lightweight web server** (provided by Django, based on Python’s built-in HTTP server).
2. Loads `settings.py` and initializes:

   * Middleware
   * URL routing
   * Installed apps
3. Listens on `127.0.0.1:8000` by default (localhost)
4. Dynamically **reloads on file changes** — you don’t have to restart manually every time.

**Key insight:**
This server is **only for development**. It’s not optimized for security or performance like a production server. Think of it as a **sandbox** where you experiment safely.

---

### **4. Deep Dive: How URLs & Views Work**

When you access `http://127.0.0.1:8000/`:

1. Django receives the HTTP request.
2. The request goes through **middleware**:

   * Functions that can modify the request/response
   * Examples: security checks, session management, logging
3. Django matches the URL to patterns in `urls.py`.
4. Calls the corresponding **view function**.
5. The view returns an HTTP response (HTML, JSON, etc.).
6. The response is sent back to your browser.

**Analogy:**
Imagine a post office:

* Request = incoming letter
* Middleware = security checks at the post office
* URL resolver = sorting office (decides which mailbox it goes to)
* View = person writing the reply
* Response = letter delivered back to the sender

---

### **5. Optional: Changing the Port**

```bash
python manage.py runserver 8080
```

* Sometimes `8000` is busy or blocked.
* You can pick any port between `1024–65535` for testing.

---

### **6. Best Practices**

* Always run your **development server inside a virtual environment**.
* Don’t commit `settings.py` secrets (like SECRET_KEY) to public repositories.
* Use `runserver` only for testing; deploy to a proper WSGI server for production.

---

### **Summary Table: Commands & Purpose**

| Command                               | Purpose                   | Deep Insight                                         |
| ------------------------------------- | ------------------------- | ---------------------------------------------------- |
| `django-admin startproject myproject` | Creates project skeleton  | Dual-layer structure separates container from config |
| `python manage.py runserver`          | Starts development server | Sandbox server with auto-reload                      |
| `python manage.py startapp appname`   | Create a Django app       | Adds modular functionality inside project            |
| `python manage.py migrate`            | Apply database schema     | Ensures models match the database structure          |

---

### **Next Steps / Reflection Questions**

1. Create a Django project and explore each file.
2. Run the server and inspect the welcome page source code — notice the HTML Django sends.
3. Think about:

   * Why `urls.py` is separate from `views.py` (modularity)
   * How middleware could intercept requests for logging, authentication, or security

**Challenge Question:**
If you wanted two different projects on the same computer, each with different Django versions, how would the virtual environment help you achieve this?

